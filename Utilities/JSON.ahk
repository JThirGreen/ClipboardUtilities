#Requires AutoHotkey v2.0

undefined() {
}
null() {
}

class JSON {

    /**
     * Parse JSON string and return as nested objects if valid
     * @param {String} jsonStr JSON string to parse
     * @param {Func} reviver Optional reviver function
     * @returns {Map | String} Generated nested objects if valid JSON or empty string if not valid JSON
     */
    static parse(jsonStr, reviver?) {
        ;tickCounter := QPC()
        ;ObjectParseList.Push({key:"", startedOn:tickCounter, endedOn:tickCounter, duration:0})
        /**
         * String of characters to be considered "whitespace"
         * @type {String}
         */
        whitespace := " `t`r`n",
        /**
         * Flag that is unset when invalid scenario is found
         * @type {true|false}
        */
        isValid := true,
        /**
         * Flag that is set when end of JSON string is found
         * @type {true|false}
         */
        isComplete := false,
        invalidReason := "",
        /** object, array, value, string, number, whitespace, true/false */
        rootObject := Map(),
        /**
         * Array to track actions while parsing
         * @type {Array<Map>}
         */
        parserActions := [],

        addNextAction("", rootObject),
        /**
         * Object that holds information of current action
         * 
         * "mode" - type of action ("object", "array", "value", "string", "number")
         * 
         * "object" - object generated by this action once completed
         * 
         * "buffer" - array of components used while action is executed
         * 
         * "returnFrom" - most recently completed child action
         * @type {Map}
         */
        action := getAction(),
        skipToIndex := 0,
        jsonCharArray := StrSplit(jsonStr)
        Loop jsonCharArray.Length {
            loopField := jsonCharArray[A_Index]
            if (isComplete) {
                if (InStr(whitespace, loopField)) {
                    continue
                }
                else {
                    isValid := false
                    invalidReason := "Unexpected non-whitespace character after JSON"
                    break
                }
            }
            action := getAction()
            if (InStr(whitespace, loopField)) {
                switch action.Get("mode") {
                    case "", "object", "array", "value":
                        continue ; Ignore whitespace when in certain modes
                }
            }
            
            switch (action.Get("mode")) {
                case "":
                    if (loopField = "{") {
                        action.Set("mode", "object")
                    }
                    else {
                        isValid := false
                        invalidReason := "String must start with `"{`""
                    }
                case "object":
                    evalObjectMode(loopField)
                case "array":
                    evalArrayMode(loopField)
                case "value":
                    evalValueMode(loopField)
                case "string":
                    if (loopField = "`"") {
                        evalStringMode(loopField)
                    }
                    else {
                        RegExMatch(jsonStr, "[^\\](\\\\)*(?P<EndQuote>`")", &endSubStr, A_Index || 1),
                        endStrIndex := endSubStr.Pos["EndQuote"],
                        fullStr := SubStr(jsonStr, A_Index, endStrIndex - A_Index),
                        splitStr := StrSplit(fullStr, "\"),
                        outerIndex := A_Index,
                        actBuffer := action.Get("buffer"),
                        escaping := false
                        for splitIndex, strFragment in splitStr {
                            newFragment := strFragment
                            if (escaping) {
                                if (!StrLen(strFragment)) {
                                    strFragment := "\"
                                }
                                actBuffer.Push("\")
                                escapedChar := SubStr(strFragment, 1, 1)
                                evalStringMode(escapedChar)
                                if (escapedChar = "\") {
                                    escaping := false
                                }
                                if (StrLen(strFragment) > 1) {
                                    newFragment := SubStr(strFragment, 2)
                                    if (actBuffer is Array && actBuffer.Length && actBuffer[-1] = "\u") {
                                        evalStringMode(SubStr(newFragment, 1, 4))
                                        newFragment := SubStr(newFragment, 5)
                                    }
                                }
                                else {
                                    newFragment := ""
                                }
                            }
                            else {
                                escaping := true
                            }

                            if (StrLen(newFragment) > 0) {
                                evalStringMode(newFragment)
                            }
                        }
                        A_Index := endStrIndex - 1
                    }
                case "number":
                    evalNumberMode(loopField)
                default:
                    isValid := false
                    invalidReason := "`"" . action.Get("mode") . "`" is not a valid parsing mode"
            }
            if (!isValid) {
                ;MsgBox(loopField . "`r`n Returned from: " . action.Get("returnFrom").Get("mode") . "`r`n" . SubStr(jsonStr, A_Index))
                break
            }
        }
        if (isValid && isComplete) {
            return rootObject
        }
        else {
            if (!invalidReason && !isComplete) {
                invalidReason := "String is not completed JSON"
            }
            MsgBox(invalidReason)
            return ""
        }
        
        getAction() {
            if (!parserActions.Length) {
                return Map()
            }
            action := parserActions[-1]
            if (action.Get("mode") = "value" && action.Get("returnFrom") != "") {
                action.Set("object", action.Get("returnFrom").Get("object"))
                if (action.Get("returnFrom").Has("raw")) {
                    action.Set("raw", action.Get("returnFrom").Get("raw"))
                }
                popThisAction()
                action := getAction()
            }
            return action
        }
        addNextAction(mode, object) {
            parserActions.Push(Map("mode", mode, "object", object, "buffer", [], "raw", Map(), "returnFrom", ""))
        }
        popThisAction() {
            poppedAct := parserActions.Pop()
            newAction := getAction()
            if (newAction != "") {
                newAction.Set("returnFrom", poppedAct)
            }
            return poppedAct
        }
        getBufferString(actionRef := getAction()) {
            bufferStr := ""
            bufferObj := actionRef.Get("buffer")
            if (Type(bufferObj) = "String") {
                bufferStr := bufferObj
            }
            else if (bufferObj is Array) {
                for bufferElement in bufferObj {
                    bufferStr .= StrReplace(bufferElement, "\\", "\") ; Unescape any skipped "\\"
                }
            }
            return bufferStr
        }
        evalObjectMode(char) {
            action := getAction()
            if (action.Get("mode") = "object") {
                key := getBufferString(action)
                /** Nested function for handling reviver transformation of value */
                setKeyValue() {
                    value := action.Get("returnFrom").Get("object")
                    context := action.Get("returnFrom").Get("raw")
                    action.Get("object").Set(key, executeReviver(key, value, context))
                }
                switch char {
                    case "`"":
                        addNextAction("string", "")
                    case ":":
                        if (key = "" && action.Get("returnFrom").Get("mode") = "string") {
                            childName := getBufferString(action.Get("returnFrom"))
                            action.Set("buffer", childName)
                            addNextAction("value", "")
                        }
                        else {
                            isValid := false
                            invalidReason := "Name must be a string"
                        }
                    case ",":
                        setKeyValue()
                        action.Set("buffer","")
                    case "}":
                        if (action.Get("returnFrom") != "" && action.Get("returnFrom").Get("mode") = "value") {
                            setKeyValue()
                        }
                        popThisAction()
                        if (!parserActions.Length)
                            isComplete := true
                    default:
                        isValid := false
                        invalidReason := "Invalid character found in object mode"
                }
            }
            else {
                isValid := false
                invalidReason := "'" . action.Get("mode") . "' cannot be evaluated as an object"
            }
        }
        evalArrayMode(char) {
            action := getAction()
            if (action.Get("mode") = "array") {
                switch char {
                    case ",":
                        action.Get("object").Push(action.Get("returnFrom").Get("object"))
                        addNextAction("value", "")
                    case "]":
                        if (action.Get("returnFrom") != "" && action.Get("returnFrom").Get("mode") = "value") {
                            action.Get("object").Push(action.Get("returnFrom").Get("object"))
                        }
                        popThisAction()
                    default:
                        if (!action.Get("returnFrom")) {
                            addNextAction("value", "")
                            evalValueMode(char)
                        }
                }
            }
            else {
                isValid := false
                invalidReason := "'" . action.Get("mode") . "' cannot be evaluated as an array"
            }
        }
        evalValueMode(char) {
            action := getAction()
            if (action.Get("mode") = "value") {
                if (!action.Get("buffer").Length) {
                    switch char {
                        case "`"":
                            addNextAction("string","")
                        case "{":
                            addNextAction("object", Map())
                        case "[":
                            addNextAction("array", [])
                        default:
                            if (RegExMatch(char,"[0-9-]")) {
                                addNextAction("number","")
                                evalNumberMode(char)
                            }
                            else
                                action.Get("buffer").Push(char)
                    }
                }
                else {
                    action.Get("buffer").Push(char)
                    thisVal := getBufferString()
                    action.Set("raw", thisVal)
                    if (InStr("true", thisVal, true)) {
                        if (thisVal = "true")
                            action.set("returnFrom", Map("object", true))
                    }
                    else if (InStr("false", thisVal, true)) {
                        if (thisVal = "false")
                            action.set("returnFrom", Map("object", false))
                    }
                    else if (InStr("null", thisVal, true)) {
                        if (thisVal = "null")
                            action.set("returnFrom", Map("object", null))
                    }
                    else {
                        isValid := false
                        invalidReason := "Invalid value " . thisVal
                    }
                }
            }
            else if (action.Get("mode") = "object") {
                evalObjectMode(char)
            }
            else if (action.Get("mode") = "array") {
                evalArrayMode(char)
            }
            else {
                isValid := false
                invalidReason := "'" . action.Get("mode") . "' cannot be evaluated as a value"
            }
        }
        evalStringMode(char) {
            if (!isValid) {
                return
            }
            action := getAction()
            if (action.Get("mode") = "string") {
                currentRaw := (Type(action.Get("raw")) = "String") ? action.Get("raw") : "`""
                action.Set("raw", currentRaw . char)

                if (!action.Get("buffer").Length) {
                    if (char = "`"") {
                        strAction := popThisAction() ; Handle immediate string termination that occurs when it's empty
                    }
                    else {
                        action.Get("buffer").Push(char) ; Initialize string buffer
                    }
                }
                else {
                    if (action.Get("buffer")[-1] = "\") { ; Handle escaped characters
                        switch char {
                            case "`"","/":
                                action.Get("buffer")[-1] := char
                            case "b":
                                action.Get("buffer")[-1] := "`b"
                            case "f":
                                action.Get("buffer")[-1] := "`f"
                            case "n":
                                action.Get("buffer")[-1] := "`n"
                            case "r":
                                action.Get("buffer")[-1] := "`r"
                            case "t":
                                action.Get("buffer")[-1] := "`t"
                            case "u":
                                action.Get("buffer")[-1] := "\u"
                            case "\":
                                action.Get("buffer")[-1] := "\\" ; Leave escaped to prevent false positives and unescape when compiling final string result
                            default:
                                isValid := false
                                invalidReason := "'\" . char . "' is not a valid character"
                        }
                    }
                    else if(SubStr(action.Get("buffer")[-1], 1, 2) = "\u") {
                        if (RegExMatch(char, "i)[0-9a-f]{1,4}")) {
                            hexCode := SubStr(action.Get("buffer")[-1], 3) . char
                            if (StrLen(hexCode) < 4) {
                                action.Get("buffer")[-1] := "\u" . hexCode
                            }
                            else {
                                action.Get("buffer")[-1] := Chr(Number("0x" . hexCode))
                            }
                        }
                        else {
                            isValid := false
                            invalidReason := "'" . char . "' is not a valid hex value"
                        }
                    }
                    else if (char = "`"") {
                        action.Set("object", getBufferString(action))
                        strAction := popThisAction()
                    }
                    else if (char = "\") {
                        action.Get("buffer").Push(char)
                    }
                    else {
                        actBuffer := action.Get("buffer")
                        actBuffer[-1] .= char
                    }
                }
            }
            else {
                isValid := false
                invalidReason := "'" . action.Get("mode") . "' cannot be evaluated as a string"
            }
        }
        evalNumberMode(char) {
            action := getAction()
            if (action.Get("mode") = "number") {
                ; Check for end conditions
                endOfValueMode := (char = "}" || char = "]" || char = ",")
                if (endOfValueMode || InStr(whitespace, char)) {
                    result := getBufferString(action)
                    if (IsNumber(result)) {
                        action.Set("object", Number(result))
                        popThisAction()
                        if (endOfValueMode) {
                            evalValueMode(char)
                        }
                    }
                    else{
                        isValid := false
                        invalidReason := "`"" . result . "`" is not a valid number"
                    }
                    return
                }

                currentRaw := (Type(action.Get("raw")) = "String") ? action.Get("raw") : ""
                action.Set("raw", currentRaw . char)
                ; buffer[1] = -?                    signage [required] (can be "-" or blank)
                ; buffer[2] = 0|1-9[0-9]*           whole number [required]
                ; buffer[3] = (.[0-9]+)?            fraction [optional] (decimal followed by digits)
                ; buffer[4] = ([Ee][+-]?[0-9]+)?    exponent [optional] ("E" followed by [optional] signage followed by digits)
                if (!action.Get("buffer").Length) {
                    if (char = "-") {
                        action.Get("buffer").Push("-")
                        return
                    }
                    else {
                        action.Get("buffer").Push("")
                    }
                }

                switch action.Get("buffer").Length {
                    case 1:
                        if (char = "0") {
                            action.Get("buffer").Push("0", "")
                        }
                        else if (RegExMatch(char, "[1-9]")) {
                            action.Get("buffer").Push(char)
                        }
                        else {
                            isValid := false
                            invalidReason := (char = ".") ? "Number cannot start with '.'" : "'" . char . "' is not valid as part of a number"
                        }
                    case 2:
                        if (RegExMatch(char, "[0-9]")) {
                            action.Get("buffer")[2] .= char
                        }
                        else if (char = ".") {
                            action.Get("buffer").Push(char)
                        }
                        else if (char = "e" || char = "E") {
                            action.Get("buffer").Push("", char)
                        }
                        else {
                            isValid := false
                            invalidReason := "'" . char . "' is not valid as part of a number"
                        }
                    case 3:
                        if (char = ".")
                            if (action.Get("buffer")[3] = "") {
                                action.Get("buffer")[3] := char
                            }
                            else {
                                isValid := false
                                invalidReason := "Error occurred while parsing '.': Ensure that there are not multiple"
                            }
                        else if (RegExMatch(char, "[0-9]"))
                            if (action.Get("buffer")[3] != "") {
                                action.Get("buffer")[3] .= char
                            }
                            else {
                                isValid := false
                                invalidReason := "Error occurred while parsing '" . char . "': Trailing zeros are not allowed"
                            }
                        else if (char = "e" || char = "E") {
                            action.Get("buffer").Push(char)
                        }
                        else {
                            isValid := false
                            invalidReason := "'" . char . "' is not valid as part of a fraction"
                        }
                    case 4:
                        if (StrLen(action.Get("buffer")[4]) = 1 && (char = "-" || char = "+")) {
                            action.Get("buffer")[4] .= char
                        }
                        else if (RegExMatch(char, "[0-9]")) {
                            action.Get("buffer")[4] .= char
                        }
                        else  {
                            isValid := false
                            invalidReason := "'" . char . "' is not valid as part of an exponent"
                        }
                    default:
                        isValid := false
                        invalidReason := "Unknown error occurred while parsing number"
                }
            }
            else {
                isValid := false
                invalidReason := "'" . action.Get("mode") . "' cannot be evaluated as a number"
            }
        }
        executeReviver(key, value, context) {
            if (IsSet(reviver) && reviver is Func) {
                newValue := ""
                switch reviver.MinParams {
                    case 0:
                        newValue := reviver()
                    case 1:
                        newValue := reviver(key)
                    case 2:
                        newValue := reviver(key, value)
                    default:
                        newValue := reviver(key, value, context)
                }
                if (Type(newValue) = "Object") {
                    newValue := ObjectPropsToMap(newValue)
                }
                return newValue
            }
            return value
        }
    }

    
    /**
     * Stringify object to JSON formatted string
     * 
     * NOTE: {@link JSON.parse()} can only recreate certain object types:
     * 
     * - strings
     * 
     * - numbers
     * 
     * - native {@link Array} objects
     * 
     * - native {@link Map} objects
     * 
     * Any other stringified object types will instead be represented by a combination of the above types
     * 
     * @param {Object} obj Object to stringify
     * @param {Func} replacer Optional replace function
     * @param {String|Integer} space Optional spacing to apply to result
     * 
     * If a number, then spacing is that many space characters up to a maximum of 10
     * @returns {String}
     */
    static stringify(obj, replacer?, space?) {
        spacer := ""
        if (IsSet(space)) {
            if (Type(space) = "String") {
                spacer := space
            }
            else if (IsNumber(space)) {
                spacer := repeatString(" ", Max(0, Min(10, space)))
            }
        }
        newLine := (StrLen(spacer) ? "`r`n" : "")
        separator := (StrLen(spacer) ? " " : "")
        
        return stringifyObject(obj, "", true)

        stringifyObject(obj, name?, isRoot?) {
            keepObj := true
            if (IsObject(obj) && obj.HasMethod("toJSON")) {
                obj := (obj.toJSON.MinParams > 1) ? obj.toJSON(name) : obj.toJSON()
            }
            thisObj := IsSet(name) ? executeReplacer(name, obj, &keepObj, (isRoot ?? false)) : obj

            if (!keepObj) {
                return ""
            }

            delimit := false
            if (thisObj is Array) {
                if (Type(thisObj) != "Array") {
                    items := []
                    for value in thisObj {
                        items.Push(value)
                    }
                    objStr := stringifyObject(customObjectToMap(thisObj, items))
                }
                else {
                    lines := ""
                    for value in thisObj {
                        line := stringifyObject(value)
                        if (StrLen(line)) {
                            if (StrLen(lines)) {
                                lines .= ","
                            }
                            lines .= newLine . spacer . line
                        }
                    }
                    objStr := "["
                    if (StrLen(lines)) {
                        objStr .= lines . newLine
                    }
                    objStr .= "]"
                }
            }
            else if (thisObj is Map) {
                if (Type(thisObj) != "Map") {
                    items := Map()
                    for key, value in thisObj {
                        items.Set(key, value)
                    }
                    objStr := stringifyObject(customObjectToMap(thisObj, items))
                }
                else {
                    lines := ""
                    for key, value in thisObj {
                        line := stringifyObject(value, key)
                        if (StrLen(line)) {
                            if (StrLen(lines)) {
                                lines .= ","
                            }
                            lines .= newLine . spacer . line
                        }
                    }
                    objStr := "{"
                    if (StrLen(lines)) {
                        objStr .= lines . newLine
                    }
                    objStr .= "}"
                }
            }
            else if (thisObj = null) {
                objStr := "null"
            }
            else if (Type(thisObj) = "Object") {
                objStr := stringifyObject(ObjectPropsToMap(thisObj))
            }
            else if (IsObject(thisObj)) {
                objStr := (thisObj is Func) ? "" : stringifyObject(customObjectToMap(thisObj))
            }
            else if (Type(thisObj) = "String") {
                objStr := escapeString(thisObj)
            }
            else if (isNumber(thisObj)) {
                objStr := String(thisObj)
            }
            else {
                objStr := "`"" . String(thisObj) . "`""
            }

            if (isRoot ?? false) {
                return objStr
            }

            prefix := IsSet(name) ? (escapeString(name) . ":" . separator) : ""
            return prefix . applyNestedSpacer(objStr)
        }

        escapeString(str) {
            escStr := "`""
            Loop Parse, str {
                switch A_LoopField {
                    case "`"", "/", "\":
                        escStr .= "\" . A_LoopField
                    case "`b":
                        escStr .= "\b"
                    case "`f":
                        escStr .= "\f"
                    case "`n":
                        escStr .= "\n"
                    case "`r":
                        escStr .= "\r"
                    case "`t":
                        escStr .= "\t"
                    default:
                        escStr .= A_LoopField
                }
            }
            escStr .= "`""
            return escStr
        }

        repeatString(str, count) {
            newStr := ""
            Loop count {
                newStr .= str
            }
            return newStr
        }

        applyNestedSpacer(str) {
            return StrReplace(str, newLine, newLine . spacer)
        }

        customObjectToMap(obj, items?) {
            content := Map()
            content.Set("type", Type(obj))
            content.Set("properties", ObjectPropsToMap(obj))
            if (IsSet(items)) {
                content.Set("items", items)
            }

            return content
        }

        executeReplacer(key, value, &keepKey, isRoot := false) {
            thisKey := key
            thisValue := value
            keepKey := true
            if (IsSet(replacer)) {
                if (replacer is Func) {
                    switch replacer.MinParams {
                        case 0:
                            thisValue := replacer()
                        case 1:
                            thisValue := replacer(thisKey)
                        default:
                            thisValue := replacer(thisKey, thisValue)
                    }
                    if (thisValue = undefined) {
                        keepKey := false
                    }
                }
                else if (replacer is Array && !isRoot) {
                    keepKey := false
                    for item in replacer {
                        if (String(item) = key) {
                            keepKey := true
                            break
                        }
                    }
                }
            }
            return thisValue
        }
    }
}

/**
 * Parse properties of an object and return as a {@link Map}
 * @param {Object} obj Object to parse
 * @returns {Map} 
 */
ObjectPropsToMap(obj) {
    propMap := Map()
    for name, value in obj.OwnProps() {
        propMap.Set(name, value)
    }
    return propMap
}